const express = require('express');
const router = express.Router();
const { stripe, PRICES } = require('../config/stripe');
const authMiddleware = require('../middleware/auth');
const User = require('../models/User');
const Subscription = require('../models/Subscription');
// Charger les associations entre les mod√®les
require('../models/associations');

// Cr√©er une session de paiement Stripe
router.post('/create-checkout-session', authMiddleware, async (req, res) => {
  try {
    const { priceType } = req.body; // 'monthly' ou 'yearly'
    const user = req.user;
    
    // Cr√©er ou r√©cup√©rer le client Stripe
    let stripeCustomerId = user.stripeCustomerId;
    if (!stripeCustomerId) {
      const customer = await stripe.customers.create({
        email: user.email,
        metadata: { userId: user.id }
      });
      stripeCustomerId = customer.id;
      await user.update({ stripeCustomerId });
    }
    
    // S√©lectionner le prix
    const priceId = priceType === 'yearly' ? PRICES.yearly : PRICES.monthly;
    
    // Debug: Log des informations
    console.log('Creating checkout session with:', {
      priceType,
      priceId,
      PRICES,
      stripeCustomerId,
      userEmail: user.email
    });
    
    // V√©rifier que le price ID existe
    if (!priceId) {
      console.error('Price ID is missing!', { priceType, PRICES });
      return res.status(400).json({ error: 'Price ID configuration error' });
    }
    
    // Cr√©er la session de checkout
    const session = await stripe.checkout.sessions.create({
      customer: stripeCustomerId,
      payment_method_types: ['card'],
      mode: 'subscription',
      line_items: [{ price: priceId, quantity: 1 }],
      success_url: `${process.env.BASE_URL || 'https://my-backend-api-cng7.onrender.com'}/payment-success.html?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.BASE_URL || 'https://my-backend-api-cng7.onrender.com'}/payment-cancel.html`,
      metadata: { userId: user.id }
    });
    
    res.json({ checkoutUrl: session.url, sessionId: session.id });
  } catch (error) {
    console.error('Error creating checkout session:', error);
    console.error('Error details:', {
      message: error.message,
      type: error.type,
      code: error.code,
      statusCode: error.statusCode
    });
    
    // Retourner une erreur plus sp√©cifique
    if (error.message && error.message.includes('No such price')) {
      res.status(400).json({ error: 'Invalid price ID' });
    } else {
      res.status(500).json({ error: error.message || 'Error creating checkout session' });
    }
  }
});

// Upgrade to annual plan
router.post('/upgrade-to-annual', authMiddleware, async (req, res) => {
  try {
    const user = req.user;
    console.log('üîÑ Upgrade request from user:', user.email);
    
    // V√©rifier si l'utilisateur a d√©j√† un plan mensuel actif
    const existingSubscription = await Subscription.findOne({
      where: {
        userId: user.id,
        status: 'active'
      }
    });
    
    console.log('üìä Existing subscription:', existingSubscription ? {
      id: existingSubscription.id,
      priceId: existingSubscription.stripePriceId,
      status: existingSubscription.status
    } : 'None');
    
    if (!existingSubscription) {
      console.log('‚ùå No active subscription found for upgrade');
      return res.status(400).json({ error: 'No active subscription found' });
    }
    
    // V√©rifier que c'est bien un plan mensuel
    if (existingSubscription.stripePriceId !== PRICES.monthly) {
      console.log('‚ö†Ô∏è User already has annual plan or different price');
      return res.status(400).json({ error: 'You already have an annual plan' });
    }
    
    // Cr√©er une session de checkout pour l'upgrade
    const session = await stripe.checkout.sessions.create({
      customer: user.stripeCustomerId,
      payment_method_types: ['card'],
      mode: 'subscription',
      line_items: [{ price: PRICES.yearly, quantity: 1 }],
      success_url: `${process.env.BASE_URL || 'https://my-backend-api-cng7.onrender.com'}/payment-success.html?session_id={CHECKOUT_SESSION_ID}&upgrade=true`,
      cancel_url: `${process.env.BASE_URL || 'https://my-backend-api-cng7.onrender.com'}/payment-cancel.html`,
      metadata: { 
        userId: user.id,
        isUpgrade: 'true',
        oldSubscriptionId: existingSubscription.stripeSubscriptionId
      },
      subscription_data: {
        metadata: {
          isUpgrade: 'true',
          oldSubscriptionId: existingSubscription.stripeSubscriptionId
        }
      }
    });
    
    res.json({ checkoutUrl: session.url, sessionId: session.id });
  } catch (error) {
    console.error('Error creating upgrade session:', error);
    res.status(500).json({ error: error.message || 'Error creating upgrade session' });
  }
});

// Webhook Stripe (appel√© automatiquement par Stripe)
router.post('/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
  console.log('üîî Webhook re√ßu!');
  const sig = req.headers['stripe-signature'];
  let event;
  
  // Si pas de webhook secret configur√©, log l'erreur mais accepter pour le test
  if (!process.env.STRIPE_WEBHOOK_SECRET) {
    console.error('‚ö†Ô∏è STRIPE_WEBHOOK_SECRET non configur√©!');
    // En mode dev/test, on peut parser l'event directement
    try {
      event = JSON.parse(req.body);
      console.log('üì¶ Event type:', event.type);
    } catch (err) {
      console.error('Erreur parsing webhook:', err);
      return res.status(400).send('Invalid payload');
    }
  } else {
    try {
      event = stripe.webhooks.constructEvent(
        req.body,
        sig,
        process.env.STRIPE_WEBHOOK_SECRET
      );
      console.log('‚úÖ Webhook signature v√©rifi√©e, event type:', event.type);
    } catch (err) {
      console.error('‚ùå Webhook signature verification failed:', err.message);
      return res.status(400).send(`Webhook Error: ${err.message}`);
    }
  }
  
  // G√©rer les diff√©rents √©v√©nements avec gestion d'erreur
  try {
    switch (event.type) {
      case 'checkout.session.completed':
        console.log('üì¶ Processing checkout.session.completed');
        await handleCheckoutComplete(event.data.object);
        break;
        
      case 'customer.subscription.updated':
        console.log('üîÑ Processing customer.subscription.updated');
        await handleSubscriptionUpdate(event.data.object);
        break;
        
      case 'customer.subscription.deleted':
        console.log('‚ùå Processing customer.subscription.deleted');
        await handleSubscriptionDeleted(event.data.object);
        break;
        
      case 'invoice.payment_succeeded':
        console.log('üí∞ Payment succeeded for invoice:', event.data.object.id);
        // Forcer une v√©rification du plan apr√®s paiement r√©ussi
        if (event.data.object.subscription) {
          const subscription = await stripe.subscriptions.retrieve(event.data.object.subscription);
          await handleSubscriptionUpdate(subscription);
        }
        break;
        
      case 'invoice.payment_failed':
        console.log('‚ùå Payment failed for invoice:', event.data.object.id);
        break;
        
      default:
        console.log(`‚ÑπÔ∏è Unhandled event type ${event.type}`);
    }
    
    res.json({ received: true });
  } catch (webhookError) {
    console.error('‚ùå Webhook processing error:', webhookError);
    // R√©pondre avec succ√®s pour √©viter que Stripe r√©essaye
    res.json({ received: true, error: webhookError.message });
  }
});

// Helper function: Handle subscription status change
async function handleSubscriptionStatusChange(subscription) {
  try {
    const dbSubscription = await Subscription.findOne({
      where: { stripeSubscriptionId: subscription.id }
    });

    if (!dbSubscription) {
      console.error('Subscription not found:', subscription.id);
      return;
    }

    const user = await User.findByPk(dbSubscription.userId);
    if (!user) {
      console.error('User not found for subscription:', subscription.id);
      return;
    }

    await dbSubscription.update({
      status: subscription.status,
      currentPeriodStart: new Date(subscription.current_period_start * 1000),
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      cancelAtPeriodEnd: subscription.cancel_at_period_end
    });

    // Update user premium status
    await user.update({
      isPremium: ['active', 'trialing'].includes(subscription.status)
    });

    // Send email notifications
    const { sendPaymentSuccessEmail, sendPaymentFailedEmail, sendSubscriptionCanceledEmail } = require('../utils/email');

    switch (subscription.status) {
      case 'active':
        if (subscription.cancel_at_period_end) {
          await sendSubscriptionCanceledEmail(user.email, {
            endDate: new Date(subscription.current_period_end * 1000)
          });
        } else {
          await sendPaymentSuccessEmail(user.email);
        }
        break;
      case 'past_due':
      case 'unpaid':
        await sendPaymentFailedEmail(user.email);
        break;
    }

  } catch (error) {
    console.error('Error handling subscription status change:', error);
  }
}

// Fonction helper : Checkout compl√©t√©
async function handleCheckoutComplete(session) {
  try {
    const userId = session.metadata.userId;
    const user = await User.findByPk(userId);
    
    if (!user) {
      console.error('User not found:', userId);
      return;
    }
    
    // R√©cup√©rer la subscription depuis Stripe
    const subscription = await stripe.subscriptions.retrieve(session.subscription);
    
    // V√©rifier si c'est un upgrade
    const isUpgrade = session.metadata.isUpgrade === 'true';
    
    console.log('üîç Checkout metadata:', {
      isUpgrade,
      oldSubscriptionId: session.metadata.oldSubscriptionId,
      userId: session.metadata.userId
    });
    
    if (isUpgrade && session.metadata.oldSubscriptionId) {
      // Annuler l'ancienne souscription
      try {
        await stripe.subscriptions.cancel(session.metadata.oldSubscriptionId);
        console.log('‚úÖ Ancienne souscription annul√©e:', session.metadata.oldSubscriptionId);
        
        // Mettre √† jour l'ancienne souscription dans la DB
        await Subscription.update(
          { status: 'canceled' },
          { where: { stripeSubscriptionId: session.metadata.oldSubscriptionId } }
        );
      } catch (cancelError) {
        console.error('Erreur lors de l\'annulation de l\'ancienne souscription:', cancelError);
      }
    }
    
    // Cr√©er ou mettre √† jour l'enregistrement subscription
    if (isUpgrade) {
      // Pour un upgrade, annuler toutes les anciennes souscriptions actives
      await Subscription.update(
        { status: 'canceled' },
        { where: { userId: user.id, status: 'active' } }
      );
      console.log('‚úÖ Anciennes souscriptions marqu√©es comme annul√©es');
    }
    
    // Cr√©er la nouvelle souscription
    try {
      const newSubscription = await Subscription.create({
        userId: user.id,
        stripeCustomerId: session.customer,
        stripeSubscriptionId: subscription.id,
        stripePriceId: subscription.items.data[0].price.id,
        status: subscription.status,
        currentPeriodStart: new Date(subscription.current_period_start * 1000),
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
        isEarlyBird: true,
        cancelAtPeriodEnd: subscription.cancel_at_period_end
      });
      console.log('‚úÖ Nouvelle souscription cr√©√©e:', newSubscription.id);
    } catch (createError) {
      console.error('‚ùå Erreur cr√©ation souscription:', createError);
      // En cas d'erreur, essayer de mettre √† jour une existante
      const existingSubscription = await Subscription.findOne({
        where: { userId: user.id },
        order: [['createdAt', 'DESC']]
      });
      
      if (existingSubscription) {
        await existingSubscription.update({
          stripeSubscriptionId: subscription.id,
          stripePriceId: subscription.items.data[0].price.id,
          status: subscription.status,
          currentPeriodStart: new Date(subscription.current_period_start * 1000),
          currentPeriodEnd: new Date(subscription.current_period_end * 1000),
          cancelAtPeriodEnd: subscription.cancel_at_period_end
        });
        console.log('‚úÖ Souscription existante mise √† jour');
      }
    }
    
    // D√©terminer le type de plan bas√© sur le price ID
    const priceId = subscription.items.data[0].price.id;
    let subscriptionPlan = 'monthly'; // Par d√©faut
    
    if (priceId === PRICES.yearly) {
      subscriptionPlan = 'yearly';
    } else if (priceId === PRICES.monthly) {
      subscriptionPlan = 'monthly';
    }
    
    console.log('‚úÖ Mise √† jour utilisateur avec plan:', subscriptionPlan);
    
    // Mettre √† jour l'utilisateur
    await user.update({
      isPremium: true,
      stripeCustomerId: session.customer,
      subscriptionPlan: subscriptionPlan,
      subscriptionStatus: 'premium',
      premiumUntil: new Date(subscription.current_period_end * 1000)
    });
    
  } catch (error) {
    console.error('Error handling checkout completion:', error);
  }
}

// Fonction helper : Subscription mise √† jour
async function handleSubscriptionUpdate(subscription) {
  try {
    const sub = await Subscription.findOne({
      where: { stripeSubscriptionId: subscription.id }
    });
    
    if (!sub) return;
    
    // Mettre √† jour le statut
    await sub.update({
      status: subscription.status,
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      cancelAtPeriodEnd: subscription.cancel_at_period_end,
      stripePriceId: subscription.items.data[0].price.id
    });
    
    // D√©terminer le type de plan
    const priceId = subscription.items.data[0].price.id;
    let subscriptionPlan = 'monthly';
    
    if (priceId === PRICES.yearly) {
      subscriptionPlan = 'yearly';
    } else if (priceId === PRICES.monthly) {
      subscriptionPlan = 'monthly';
    }
    
    // Mettre √† jour l'utilisateur
    const user = await User.findByPk(sub.userId);
    if (user) {
      await user.update({
        isPremium: subscription.status === 'active',
        premiumUntil: new Date(subscription.current_period_end * 1000),
        subscriptionPlan: subscriptionPlan,
        subscriptionStatus: subscription.status === 'active' ? 'premium' : 'inactive'
      });
    }
    
  } catch (error) {
    console.error('Erreur handleSubscriptionUpdate:', error);
  }
}

// Fonction helper : Subscription annul√©e
async function handleSubscriptionDeleted(subscription) {
  try {
    const sub = await Subscription.findOne({
      where: { stripeSubscriptionId: subscription.id }
    });
    
    if (!sub) return;
    
    await sub.update({ status: 'canceled' });
    
    // Retirer le statut Premium
    const user = await User.findByPk(sub.userId);
    if (user) {
      await user.update({
        isPremium: false,
        premiumUntil: null
      });
      
      // Envoyer email de fin d'abonnement
      // await emailService.sendSubscriptionEnded(user.email, user.name);
    }
    
  } catch (error) {
    console.error('Erreur handleSubscriptionDeleted:', error);
  }
}

// Route de test pour v√©rifier les webhooks
router.get('/webhook-test', (req, res) => {
  res.json({ 
    message: 'Webhook endpoint is accessible',
    url: `${process.env.BASE_URL || 'https://my-backend-api-cng7.onrender.com'}/api/subscription/webhook`
  });
});

// Obtenir le statut de l'abonnement
router.get('/status', authMiddleware, async (req, res) => {
  try {
    const subscription = await Subscription.findOne({
      where: { 
        userId: req.user.id,
        status: 'active'
      }
    });
    
    if (!subscription) {
      return res.json({
        hasSubscription: false,
        isPremium: false,
        flashcardLimit: 100
      });
    }
    
    res.json({
      hasSubscription: true,
      isPremium: true,
      subscription: {
        status: subscription.status,
        currentPeriodEnd: subscription.currentPeriodEnd,
        cancelAtPeriodEnd: subscription.cancelAtPeriodEnd,
        isEarlyBird: subscription.isEarlyBird
      },
      flashcardLimit: -1 // -1 = illimit√©
    });
    
  } catch (error) {
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration du statut' });
  }
});

// Annuler l'abonnement
router.post('/cancel', authMiddleware, async (req, res) => {
  try {
    console.log('üö´ Demande d\'annulation pour:', req.user.email);
    
    // Normaliser les donn√©es de l'utilisateur (√©viter les probl√®mes de casse)
    const userEmail = req.user.email.toLowerCase().trim();
    const userPlan = req.user.subscriptionPlan ? req.user.subscriptionPlan.toLowerCase().trim() : null;
    
    // V√©rifier d'abord le statut dans la table Users
    console.log('üìä Statut utilisateur:', {
      email: userEmail,
      isPremium: req.user.isPremium,
      subscriptionPlan: userPlan,
      stripeCustomerId: req.user.stripeCustomerId
    });
    
    // Si l'utilisateur n'est pas premium selon la table Users, erreur
    if (!req.user.isPremium || !userPlan) {
      return res.status(400).json({ error: 'You do not have an active subscription' });
    }
    
    // D'abord v√©rifier si l'utilisateur a un Stripe customer ID
    if (!req.user.stripeCustomerId) {
      return res.status(400).json({ error: 'No payment information found' });
    }
    
    // Chercher la souscription active ou en essai dans la DB
    const subscription = await Subscription.findOne({
      where: { 
        userId: req.user.id,
        status: ['active', 'trialing', 'past_due'] // Inclure tous les statuts "actifs"
      },
      order: [['createdAt', 'DESC']]
    });
    
    if (!subscription) {
      console.log('‚ùå Aucune souscription dans la DB, v√©rification directe avec Stripe...');
      
      // Si pas dans la DB, chercher directement dans Stripe
      try {
        const stripeSubscriptions = await stripe.subscriptions.list({
          customer: req.user.stripeCustomerId,
          limit: 10 // R√©cup√©rer plus de souscriptions pour trouver la bonne
        });
        
        // Filtrer pour trouver une souscription annulable
        const activeSubscriptions = stripeSubscriptions.data.filter(s => 
          ['active', 'trialing', 'past_due'].includes(s.status) && 
          !s.cancel_at_period_end
        );
        
        if (activeSubscriptions.length === 0) {
          // V√©rifier s'il y a des souscriptions d√©j√† annul√©es
          const canceledSubs = stripeSubscriptions.data.filter(s => s.cancel_at_period_end);
          if (canceledSubs.length > 0) {
            return res.status(400).json({ 
              error: 'Subscription already scheduled for cancellation',
              endDate: new Date(canceledSubs[0].current_period_end * 1000)
            });
          }
          return res.status(404).json({ error: 'No active subscription found in Stripe' });
        }
        
        const stripeSub = activeSubscriptions[0]; // Prendre la premi√®re souscription active
        console.log('‚úÖ Souscription Stripe trouv√©e:', stripeSub.id);
        
        // NOUVELLE LOGIQUE : Cr√©er l'enregistrement manquant avant d'annuler
        console.log('üîß Cr√©ation automatique de l\'enregistrement Subscription manquant...');
        
        try {
          // V√©rifier si cette souscription existe d√©j√† (peut-√™tre inactive)
          let dbSubscription = await Subscription.findOne({
            where: { stripeSubscriptionId: stripeSub.id }
          });
          
          if (dbSubscription) {
            // Mettre √† jour l'existante
            await dbSubscription.update({
              status: stripeSub.status,
              userId: req.user.id,
              currentPeriodEnd: new Date(stripeSub.current_period_end * 1000)
            });
            console.log('‚úÖ Enregistrement existant mis √† jour');
          } else {
            // Cr√©er un nouvel enregistrement
            dbSubscription = await Subscription.create({
              userId: req.user.id,
              stripeCustomerId: req.user.stripeCustomerId,
              stripeSubscriptionId: stripeSub.id,
              stripePriceId: stripeSub.items.data[0].price.id,
              status: stripeSub.status,
              currentPeriodStart: new Date(stripeSub.current_period_start * 1000),
              currentPeriodEnd: new Date(stripeSub.current_period_end * 1000),
              cancelAtPeriodEnd: false,
              isEarlyBird: true
            });
            console.log('‚úÖ Nouvel enregistrement Subscription cr√©√©');
          }
          
          // Maintenant annuler dans Stripe
          const updatedSub = await stripe.subscriptions.update(
            stripeSub.id,
            { cancel_at_period_end: true }
          );
          
          // Mettre √† jour l'enregistrement DB
          await dbSubscription.update({
            cancelAtPeriodEnd: true
          });
          
          const endDate = new Date(updatedSub.current_period_end * 1000);
          
          return res.json({
            success: true,
            message: `Subscription canceled successfully. You will remain Premium until ${endDate.toLocaleDateString('en-US')}`,
            endDate: endDate,
            recordCreated: !dbSubscription
          });
          
        } catch (createError) {
          console.error('‚ùå Erreur cr√©ation/mise √† jour:', createError);
          // Continuer quand m√™me avec l'annulation Stripe seule
        }
        
      } catch (stripeError) {
        console.error('‚ùå Erreur Stripe directe:', stripeError);
        return res.status(500).json({ 
          error: 'Failed to cancel subscription in Stripe',
          details: stripeError.message 
        });
      }
    }
    
    console.log('üìä Souscription trouv√©e:', {
      id: subscription.id,
      stripeId: subscription.stripeSubscriptionId,
      priceId: subscription.stripePriceId
    });
    
    try {
      // Annuler sur Stripe (√† la fin de la p√©riode)
      const stripeSubscription = await stripe.subscriptions.update(
        subscription.stripeSubscriptionId, 
        {
          cancel_at_period_end: true
        }
      );
      
      console.log('‚úÖ Souscription Stripe mise √† jour:', stripeSubscription.cancel_at_period_end);
      
      // Mettre √† jour dans la DB
      await subscription.update({ 
        cancelAtPeriodEnd: true,
        status: stripeSubscription.status
      });
      
      // Calculer la date de fin
      const endDate = subscription.currentPeriodEnd || 
                     new Date(stripeSubscription.current_period_end * 1000);
      
      res.json({
        success: true,
        message: `Subscription canceled. You will remain Premium until ${endDate.toLocaleDateString('en-US')}`,
        endDate: endDate
      });
      
    } catch (stripeError) {
      console.error('‚ùå Erreur Stripe:', stripeError);
      return res.status(500).json({ 
        error: 'Failed to cancel subscription with payment provider',
        details: stripeError.message 
      });
    }
    
  } catch (error) {
    console.error('‚ùå Erreur g√©n√©rale annulation:', error);
    res.status(500).json({ 
      error: 'Failed to cancel subscription',
      details: error.message 
    });
  }
});

// R√©activer l'abonnement (annuler l'annulation)
router.post('/reactivate', authMiddleware, async (req, res) => {
  try {
    console.log('‚ôªÔ∏è Demande de r√©activation pour:', req.user.email);
    
    // Chercher la souscription active avec annulation programm√©e
    const subscription = await Subscription.findOne({
      where: { 
        userId: req.user.id,
        status: 'active',
        cancelAtPeriodEnd: true
      },
      order: [['createdAt', 'DESC']]
    });
    
    if (!subscription) {
      return res.status(404).json({ error: 'No subscription scheduled for cancellation found' });
    }
    
    try {
      // R√©activer sur Stripe
      const stripeSubscription = await stripe.subscriptions.update(
        subscription.stripeSubscriptionId, 
        {
          cancel_at_period_end: false
        }
      );
      
      console.log('‚úÖ Souscription Stripe r√©activ√©e');
      
      // Mettre √† jour dans la DB
      await subscription.update({ 
        cancelAtPeriodEnd: false
      });
      
      res.json({
        success: true,
        message: 'Subscription reactivated successfully!',
        subscription: {
          status: stripeSubscription.status,
          currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000)
        }
      });
      
    } catch (stripeError) {
      console.error('‚ùå Erreur Stripe:', stripeError);
      return res.status(500).json({ 
        error: 'Failed to reactivate subscription',
        details: stripeError.message 
      });
    }
    
  } catch (error) {
    console.error('‚ùå Erreur r√©activation:', error);
    res.status(500).json({ 
      error: 'Failed to reactivate subscription',
      details: error.message 
    });
  }
});

// Route de synchronisation forc√©e avec Stripe
router.post('/sync-stripe', authMiddleware, async (req, res) => {
  try {
    console.log('üîÑ Synchronisation Stripe pour:', req.user.email);
    
    if (!req.user.stripeCustomerId) {
      return res.status(400).json({ error: 'No Stripe customer ID found' });
    }
    
    // R√©cup√©rer toutes les souscriptions Stripe
    const stripeSubscriptions = await stripe.subscriptions.list({
      customer: req.user.stripeCustomerId,
      limit: 100
    });
    
    console.log(`üìä ${stripeSubscriptions.data.length} souscriptions Stripe trouv√©es`);
    
    // R√©cup√©rer toutes les souscriptions DB
    const dbSubscriptions = await Subscription.findAll({
      where: { userId: req.user.id }
    });
    
    const dbSubIds = dbSubscriptions.map(s => s.stripeSubscriptionId);
    let created = 0;
    let updated = 0;
    
    // Synchroniser chaque souscription Stripe
    for (const stripeSub of stripeSubscriptions.data) {
      const existingDb = dbSubscriptions.find(db => db.stripeSubscriptionId === stripeSub.id);
      
      if (!existingDb) {
        // Cr√©er la souscription manquante
        try {
          await Subscription.create({
            userId: req.user.id,
            stripeCustomerId: req.user.stripeCustomerId,
            stripeSubscriptionId: stripeSub.id,
            stripePriceId: stripeSub.items.data[0].price.id,
            status: stripeSub.status,
            currentPeriodStart: new Date(stripeSub.current_period_start * 1000),
            currentPeriodEnd: new Date(stripeSub.current_period_end * 1000),
            cancelAtPeriodEnd: stripeSub.cancel_at_period_end || false
          });
          created++;
          console.log(`‚úÖ Cr√©√©: ${stripeSub.id}`);
        } catch (createError) {
          console.error(`‚ùå Erreur cr√©ation ${stripeSub.id}:`, createError.message);
        }
      } else if (existingDb.status !== stripeSub.status || 
                 existingDb.cancelAtPeriodEnd !== stripeSub.cancel_at_period_end) {
        // Mettre √† jour si diff√©rent
        await existingDb.update({
          status: stripeSub.status,
          cancelAtPeriodEnd: stripeSub.cancel_at_period_end || false,
          currentPeriodEnd: new Date(stripeSub.current_period_end * 1000)
        });
        updated++;
        console.log(`üîÑ Mis √† jour: ${stripeSub.id}`);
      }
    }
    
    res.json({
      success: true,
      message: `Sync completed: ${created} created, ${updated} updated`,
      stripe: stripeSubscriptions.data.length,
      database: dbSubscriptions.length + created,
      created,
      updated
    });
    
  } catch (error) {
    console.error('‚ùå Erreur sync:', error);
    res.status(500).json({ 
      error: 'Sync failed',
      details: error.message 
    });
  }
});

// [D√âSACTIV√â] Route temporaire pour cr√©er une souscription manquante
// Cette fonctionnalit√© est maintenant int√©gr√©e dans la route /cancel
/*
router.post('/create-missing', authMiddleware, async (req, res) => {
  try {
    console.log('üîß Cr√©ation de souscription manquante pour:', req.user.email);
    
    // V√©rifier s'il y a d√©j√† une souscription active
    const existingActive = await Subscription.findOne({
      where: { 
        userId: req.user.id,
        status: 'active'
      }
    });
    
    if (existingActive) {
      return res.json({ 
        success: false, 
        message: 'An active subscription already exists',
        subscription: existingActive
      });
    }
    
    // V√©rifier avec Stripe
    if (!req.user.stripeCustomerId) {
      return res.status(400).json({ error: 'No Stripe customer ID found' });
    }
    
    // Lister les souscriptions Stripe
    const stripeSubscriptions = await stripe.subscriptions.list({
      customer: req.user.stripeCustomerId,
      status: 'active',
      limit: 1
    });
    
    if (stripeSubscriptions.data.length === 0) {
      return res.status(404).json({ error: 'No active Stripe subscription found' });
    }
    
    const stripeSub = stripeSubscriptions.data[0];
    console.log('‚úÖ Souscription Stripe trouv√©e:', stripeSub.id);
    
    // V√©rifier d'abord si cette souscription existe d√©j√† (peut-√™tre avec un autre statut)
    const existingSubWithId = await Subscription.findOne({
      where: { stripeSubscriptionId: stripeSub.id }
    });
    
    if (existingSubWithId) {
      // Mettre √† jour l'existante au lieu de cr√©er
      console.log('‚ö†Ô∏è Souscription existante trouv√©e, mise √† jour...');
      await existingSubWithId.update({
        userId: req.user.id,
        status: stripeSub.status,
        currentPeriodEnd: new Date(stripeSub.current_period_end * 1000),
        cancelAtPeriodEnd: stripeSub.cancel_at_period_end
      });
      
      return res.json({
        success: true,
        message: 'Existing subscription record updated',
        subscription: existingSubWithId,
        updated: true
      });
    }
    
    // Cr√©er l'enregistrement dans la DB
    const newSubscription = await Subscription.create({
      userId: req.user.id,
      stripeCustomerId: req.user.stripeCustomerId,
      stripeSubscriptionId: stripeSub.id,
      stripePriceId: stripeSub.items.data[0].price.id,
      status: stripeSub.status,
      currentPeriodStart: new Date(stripeSub.current_period_start * 1000),
      currentPeriodEnd: new Date(stripeSub.current_period_end * 1000),
      cancelAtPeriodEnd: stripeSub.cancel_at_period_end,
      isEarlyBird: false
    });
    
    console.log('‚úÖ Souscription cr√©√©e dans la DB:', newSubscription.id);
    
    res.json({
      success: true,
      message: 'Subscription record created successfully',
      subscription: newSubscription
    });
    
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation souscription manquante:', error);
    res.status(500).json({ 
      error: 'Failed to create subscription record',
      details: error.message 
    });
  }
});
*/

// [D√âSACTIV√â] Route de diagnostic des souscriptions  
// Garder pour r√©f√©rence future si besoin de debug
/*
router.get('/debug/:userId?', authMiddleware, async (req, res) => {
  try {
    const userId = req.params.userId || req.user.id;
    
    // V√©rifier que c'est le bon utilisateur ou un admin
    if (userId !== req.user.id && req.user.email !== 'akramhimmich00@gmail.com') {
      return res.status(403).json({ error: 'Unauthorized' });
    }
    
    const user = await User.findByPk(userId);
    
    // Chercher toutes les souscriptions
    const subscriptions = await Subscription.findAll({
      where: { userId: userId },
      order: [['createdAt', 'DESC']]
    });
    
    // V√©rifier avec Stripe
    let stripeSubscriptions = [];
    if (user.stripeCustomerId) {
      try {
        const stripeSubs = await stripe.subscriptions.list({
          customer: user.stripeCustomerId,
          limit: 10
        });
        stripeSubscriptions = stripeSubs.data;
      } catch (stripeError) {
        console.error('Stripe error:', stripeError);
      }
    }
    
    res.json({
      user: {
        id: user.id,
        email: user.email,
        isPremium: user.isPremium,
        subscriptionPlan: user.subscriptionPlan,
        stripeCustomerId: user.stripeCustomerId
      },
      database: {
        count: subscriptions.length,
        subscriptions: subscriptions.map(s => ({
          id: s.id,
          status: s.status,
          stripeSubscriptionId: s.stripeSubscriptionId,
          stripePriceId: s.stripePriceId,
          cancelAtPeriodEnd: s.cancelAtPeriodEnd,
          createdAt: s.createdAt,
          currentPeriodEnd: s.currentPeriodEnd
        }))
      },
      stripe: {
        count: stripeSubscriptions.length,
        subscriptions: stripeSubscriptions.map(s => ({
          id: s.id,
          status: s.status,
          priceId: s.items.data[0].price.id,
          interval: s.items.data[0].price.recurring.interval,
          currentPeriodEnd: new Date(s.current_period_end * 1000),
          cancelAtPeriodEnd: s.cancel_at_period_end
        }))
      },
      prices: PRICES
    });
  } catch (error) {
    console.error('Debug error:', error);
    res.status(500).json({ error: error.message });
  }
});
*/

module.exports = router;
